---
layout: default
title: Colibrì DB – RDBMS in Swift basato su codice verificato
description: Colibrì DB integra BufferPool, FileWAL, MVCCManager, QueryExecutor e i sottosistemi distribuiti implementati nel sorgente Swift per offrire un RDBMS sperimentale formale e ad alte prestazioni.
---

<section class="hero hero--home">
  <div class="shell hero__inner">
    <div class="hero__content">
      <span class="hero__eyebrow">Derivato da Sources/ColibriCore</span>
      <h1 class="hero__title">Un RDBMS Swift con stack formale end-to-end</h1>
      <p class="hero__lede">
        L'attore <code>ColibrìDB</code> definito in <code>Sources/ColibriCore/Database/ColibrìDB.swift</code> compone
        <code>BufferPool.swift</code>, <code>FileWAL.swift</code>, <code>MVCCManager.swift</code> e <code>QueryExecutor.swift</code>
        per fornire concorrenza snapshot, WAL ARIES e ottimizzazione fisica senza sacrificare la leggibilità del codice Swift 6.2.
      </p>
      <div class="hero__actions">
        <a class="btn btn--primary" href="{{ '/architecture.html' | relative_url }}">Leggi l'architettura →</a>
        <a class="btn btn--ghost" href="https://github.com/gpicchiarelli/Colibri-DB/tree/main/Sources" target="_blank" rel="noreferrer">Apri il sorgente ↗</a>
      </div>
      <ul class="metric-list">
        <li class="metric">
          <span class="metric__label">Storage</span>
          <p class="metric__value">
            <code>BufferPool/BufferPool.swift</code> implementa clock-sweep, <code>Storage/HeapTable.swift</code>
            gestisce pagine a slot e <code>WAL/FileWAL.swift</code> applica ARIES con group commit.
          </p>
        </li>
        <li class="metric">
          <span class="metric__label">Consistenza</span>
          <p class="metric__value">
            <code>Transaction/LockManager.swift</code> e <code>Transaction/TransactionManager.swift</code> coordinano lock intent,
            mentre <code>MVCC/MVCCManager.swift</code> assicura snapshot isolation e garbage collection.
          </p>
        </li>
        <li class="metric">
          <span class="metric__label">SQL Pipeline</span>
          <p class="metric__value">
            <code>SQL/SQLProcessor.swift</code>, <code>Planner/QueryPlanner.swift</code> e
            <code>Query/QueryExecutor.swift</code> coprono parsing, pianificazione cost-based e operatori fisici.
          </p>
        </li>
      </ul>
    </div>
    <aside class="hero__panel">
      <h2>Capacità distribuite dal codice</h2>
      <ul>
        <li><code>Consensus/RaftConsensusManager.swift</code> fornisce elezione del leader e replica log-sicura.</li>
        <li><code>TwoPhaseCommit/TwoPhaseCommitManager.swift</code> coordina commit atomici tra nodi.</li>
        <li><code>Sharding/ShardingManager.swift</code> e <code>Replication/ReplicationManager.swift</code> orchestrano partizionamento e copie calde.</li>
        <li><code>DistributedQuery/DistributedQuery.swift</code> spinge i piani SQL oltre i confini del cluster.</li>
      </ul>
    </aside>
  </div>
</section>

<section class="section">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Layer dal repository</span>
      <h2 class="section__title">Architettura modulare con responsabilità nette</h2>
      <p class="section__lede">
        Ogni directory del core Swift racchiude un sottosistema isolato: dagli heap slotted a MVCC, dai cataloghi
        alla sicurezza. La segmentazione permette di ricondurre ogni feature direttamente al file sorgente e alla
        rispettiva specifica TLA+.
      </p>
    </header>
    <div class="grid grid--three">
      <article class="card">
        <span class="badge">Storage &amp; WAL</span>
        <h3 class="card__title">Buffering e durabilità</h3>
        <p class="card__body">
          <code>BufferPool.swift</code> gestisce pin, dirty set e clock-hand; <code>StorageManager.swift</code> incapsula IO
          su disco; <code>FileWAL.swift</code> mantiene il log sequenziale e checkpointing ARIES.
        </p>
        <ul class="card__list">
          <li><code>Storage/HeapTable.swift</code> gestisce slot, free space e tombstone.</li>
          <li><code>WAL/FileWAL.swift</code> traccia <abbr title="Log Sequence Number">LSN</abbr>, DPT e group commit.</li>
          <li><code>Recovery/ARIESRecovery.swift</code> rigioca REDO/UNDO con controllo idempotente.</li>
        </ul>
      </article>
      <article class="card">
        <span class="badge">Transazioni</span>
        <h3 class="card__title">Gestione della concorrenza</h3>
        <p class="card__body">
          In <code>Transaction/TransactionManager.swift</code> convivono lifecycle, commit e abort; <code>LockManager.swift</code>
          implementa grafi wait-for e fairness; <code>MVCCManager.swift</code> costruisce snapshot e version chain.
        </p>
        <ul class="card__list">
          <li><code>Constraints</code> valida chiavi e foreign key a livello di catalogo.</li>
          <li><code>MultiTenancy/ConnectionPooling.swift</code> offre pool elastico con eviction temporale.</li>
          <li><code>Authentication/AuthenticationManager.swift</code> e <code>Security/RolesPermissions.swift</code> gestiscono RBAC.</li>
        </ul>
      </article>
      <article class="card">
        <span class="badge">Query Engine</span>
        <h3 class="card__title">Dalla pianificazione all'esecuzione</h3>
        <p class="card__body">
          <code>SQL/SQLProcessor.swift</code> traduce la sintassi; <code>Planner/QueryPlanner.swift</code> produce piani logici;
          <code>QueryExecutor.swift</code> offre scan, join hash/sort-merge, aggregazioni e sorting.
        </p>
        <ul class="card__list">
          <li><code>Indexes/IndexManager.swift</code> supporta B-Tree, hash, bitmap e full-text.</li>
          <li><code>Optimization/OptimizationManager.swift</code> applica strategie su query, IO e memoria.</li>
          <li><code>Statistics</code> alimenta il planner con cardinalità e distribuzioni.</li>
        </ul>
      </article>
    </div>
  </div>
</section>

<section class="section section--muted">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Percorso di una query</span>
      <h2 class="section__title">Pipeline SQL tracciabile file per file</h2>
      <p class="section__lede">
        L'esecuzione attraversa componenti Swift espliciti: dal parsing nel modulo SQL, alla pianificazione, sino al
        commit sullo storage con sincronizzazione WAL.
      </p>
    </header>
    <div class="grid grid--two">
      <div class="card card--soft">
        <h3 class="card__title">1. Parsing e normalizzazione</h3>
        <p class="card__body">
          <code>SQL/SQLProcessor.swift</code> gestisce il ciclo parse → validate → rewrite e popola il catalogo attraverso
          <code>Catalog/Catalog.swift</code> e <code>CatalogManager.swift</code>.
        </p>
        <ul class="card__list">
          <li><code>SQL/ConstraintManager.swift</code> applica vincoli dichiarativi.</li>
          <li><code>Core/Types.swift</code> definisce il sistema di tipi relazionali.</li>
        </ul>
      </div>
      <div class="card card--soft">
        <h3 class="card__title">2. Pianificazione e ottimizzazione</h3>
        <p class="card__body">
          <code>Planner/QueryPlanner.swift</code> costruisce albero logico; <code>Optimization/OptimizationManager.swift</code>
          valuta strategie e costi, arricchiti da <code>Statistics</code> e <code>Performance</code>.
        </p>
        <ul class="card__list">
          <li><code>Query/PreparedStatements.swift</code> riduce overhead per workload ripetuti.</li>
          <li><code>Indexes</code> fornisce metadati di selettività e access path.</li>
        </ul>
      </div>
      <div class="card card--soft">
        <h3 class="card__title">3. Esecuzione fisica</h3>
        <p class="card__body">
          <code>Query/QueryExecutor.swift</code> orchestralizza pipeline, buffer e operatori; raccoglie statistiche runtime
          e richiama <code>TransactionManager</code> per commit/abort.
        </p>
        <ul class="card__list">
          <li><code>Engine</code> integra esecuzione, scheduling e feedback.</li>
          <li><code>Performance</code> aggiorna metriche per l'ottimizzatore.</li>
        </ul>
      </div>
      <div class="card card--soft">
        <h3 class="card__title">4. Scrittura durabile</h3>
        <p class="card__body">
          <code>WAL/FileWAL.swift</code> serializza record con prevLSN, <code>Recovery/ARIESRecovery.swift</code> gestisce redo/undo
          e <code>BufferPool</code> esegue flush rispettando il log-before-data.
        </p>
        <ul class="card__list">
          <li><code>Recovery/PointInTimeRecovery.swift</code> abilita ripristino temporale.</li>
          <li><code>Storage/VACUUM.swift</code> pulisce versioni obsolete.</li>
        </ul>
      </div>
    </div>
  </div>
</section>

<section class="section section--contrast">
  <div class="shell">
    <header class="section__header section__header--center">
      <span class="section__eyebrow">Distribuzione e resilienza</span>
      <h2 class="section__title">Consenso, coordinamento e replica nativi</h2>
      <p class="section__lede">
        I moduli distribuiti dichiarano invarianti direttamente nel codice: consenso Raft, commit a due fasi, query
        distribuite e controlli di salute centralizzati.
      </p>
    </header>
    <div class="highlight-grid">
      <div class="highlight">
        <strong>Consenso</strong>
        <p><code>Consensus/RaftConsensusManager.swift</code> mantiene log matching, election safety e gestione timer.</p>
      </div>
      <div class="highlight">
        <strong>Transazioni globali</strong>
        <p><code>TwoPhaseCommit/TwoPhaseCommitManager.swift</code> governa prepare/commit/abort con messaggistica esplicita.</p>
      </div>
      <div class="highlight">
        <strong>Replica &amp; Sharding</strong>
        <p><code>Replication/ReplicationManager.swift</code> e <code>Sharding/ShardingManager.swift</code> definiscono layout di partizioni e repliche.</p>
      </div>
      <div class="highlight">
        <strong>Query distribuite</strong>
        <p><code>DistributedQuery/DistributedQuery.swift</code> coordina pianificazione federata e merge dei risultati.</p>
      </div>
    </div>
  </div>
</section>

<section class="section">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Operatività guidata dal codice</span>
      <h2 class="section__title">Monitoring, sicurezza e tooling immediatamente disponibili</h2>
      <p class="section__lede">
        Le funzionalità di gestione non sono accessorie: vivono accanto ai percorsi critici ed espongono API per CLI e server.
      </p>
    </header>
    <div class="grid grid--three">
      <article class="card">
        <span class="badge">Monitoraggio</span>
        <h3 class="card__title">Metriche e health check</h3>
        <p class="card__body">
          <code>Monitoring/Monitor.swift</code> registra gauge, histogram e summary; integra soglie e valutazioni di stato
          complessivo interrogando <code>ColibrìDB.getStatistics()</code>.
        </p>
        <ul class="card__list">
          <li><code>Performance/Benchmarking.swift</code> e <code>Statistics/StatisticsMaintenance.swift</code> producono insight per tuning.</li>
          <li><code>Policy</code> e <code>Security</code> applicano limiti e audit.</li>
        </ul>
      </article>
      <article class="card">
        <span class="badge">Backup &amp; Recovery</span>
        <h3 class="card__title">Protezione dei dati</h3>
        <p class="card__body">
          <code>Backup/BackupManager.swift</code> gestisce snapshot e cataloghi; <code>Recovery/ARIESRecoveryManager.swift</code>
          esegue analisi, redo e undo aderendo alle invarianti TLA+.
        </p>
        <ul class="card__list">
          <li><code>ErrorRecovery</code> cattura path di fault con retry controllato.</li>
          <li><code>Policy/PolicyManager.swift</code> gestisce quote e criteri di retention.</li>
        </ul>
      </article>
      <article class="card">
        <span class="badge">Tooling</span>
        <h3 class="card__title">Servizi e CLI</h3>
        <p class="card__body">
          <code>ColibriServer/Server.swift</code> espone un server HTTP concorrente via <code>Network</code>;
          <code>Sources/coldb/main.swift</code> delega al modulo <code>ColibriCLI</code> per automazioni da terminale.
        </p>
        <ul class="card__list">
          <li><code>Platform/MemoryManagement.swift</code> gestisce pool e quote.</li>
          <li><code>Testing</code> contiene scenari end-to-end e generatori di workload.</li>
        </ul>
      </article>
    </div>
  </div>
</section>

<section class="section section--muted">
  <div class="shell">
    <header class="section__header section__header--center">
      <span class="section__eyebrow">Per iniziare</span>
      <h2 class="section__title">Esplora le specifiche TLA+ e il wiki generato dal codice</h2>
      <p class="section__lede">
        Ogni sottosistema Swift rimanda a un modulo TLA+. Consulta le pagine dedicate per navigare tra invarianti,
        proprietà di sicurezza e guide operative derivate direttamente dal repository.
      </p>
    </header>
    <div class="highlight-grid">
      <div class="highlight">
        <strong>Specifiche</strong>
        <p>Scopri i moduli formali per WAL, consensus, 2PC e MVCC.</p>
        <a class="btn btn--subtle" href="{{ '/tla-specifications.html' | relative_url }}">Vai alle specifiche →</a>
      </div>
      <div class="highlight">
        <strong>Wiki</strong>
        <p>Il wiki in <code>docs/wiki</code> viene renderizzato tramite <code>doc.html</code> usando il nuovo layout.</p>
        <a class="btn btn--subtle" href="{{ '/wiki/Home.html' | relative_url }}">Apri il wiki →</a>
      </div>
    </div>
  </div>
</section>
