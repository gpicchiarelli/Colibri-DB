---
layout: default
title: Architettura di Colibrì DB
description: Architettura modulare derivata dai file Swift del progetto: storage, MVCC, query planner, distribuzione e observability collegati alle rispettive specifiche TLA+.
---

<section class="hero hero--sub">
  <div class="shell hero__inner hero__inner--compact">
    <span class="hero__eyebrow">Sorgenti Swift come blueprint</span>
    <h1 class="hero__title">Architettura modulare, TLA+ allineata</h1>
    <p class="hero__lede">
      Il runtime descritto in <code>Sources/ColibriCore</code> separa chiaramente buffering, transazioni, query e
      distribuzione. Ogni attore Swift rimanda al proprio modulo TLA+, permettendo di collegare invarianti formali e
      comportamento concreto.
    </p>
  </div>
</section>

<section class="section">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Layer principali</span>
      <h2 class="section__title">Dal disco al consensus: blocchi indipendenti</h2>
      <p class="section__lede">
        Il repository modella ogni funzione vitale dentro un sotto-pacchetto. Navigare la cartella <code>Sources/ColibriCore</code>
        equivale a seguire il percorso dei dati dopo un comando SQL.
      </p>
    </header>
    <div class="layer-map">
      <article class="layer-map__group">
        <div class="layer-map__title">
          <span>Storage &amp; Buffering</span>
          <code>Storage</code>
        </div>
        <ul class="layer-map__list">
          <li><code>BufferPool/BufferPool.swift</code> – cache clock-sweep con pin-count, dirty set e LSN.</li>
          <li><code>Storage/HeapTable.swift</code> – pagine slotted, free list e gestione tombstone.</li>
          <li><code>Storage/StorageManager.swift</code> – astrazione IO su file e page manager.</li>
          <li><code>WAL/FileWAL.swift</code> – ARIES, prevLSN, dirty page table e group commit.</li>
        </ul>
      </article>
      <article class="layer-map__group">
        <div class="layer-map__title">
          <span>Transazioni &amp; MVCC</span>
          <code>Transaction</code>
        </div>
        <ul class="layer-map__list">
          <li><code>Transaction/TransactionManager.swift</code> – lifecycle, commit, abort e log tail.</li>
          <li><code>Transaction/LockManager.swift</code> – lock intent, wait-for graph e deadlock detection.</li>
          <li><code>MVCC/MVCCManager.swift</code> – snapshot isolation, version chain, vacuum cooperativo.</li>
          <li><code>TwoPhaseCommit/TwoPhaseCommitManager.swift</code> – coordinamento prepare/commit distribuito.</li>
        </ul>
      </article>
      <article class="layer-map__group">
        <div class="layer-map__title">
          <span>Catalogo &amp; Query</span>
          <code>SQL / Query</code>
        </div>
        <ul class="layer-map__list">
          <li><code>SQL/SQLProcessor.swift</code> – parsing, rewrite e validazione DDL/DML.</li>
          <li><code>Catalog/Catalog.swift</code> – metadati di tabelle, indici e constraint.</li>
          <li><code>Planner/QueryPlanner.swift</code> – costruzione di piani logici.</li>
          <li><code>Query/QueryExecutor.swift</code> – operatori fisici (scan, join hash/sort, aggregate).</li>
          <li><code>Optimization/OptimizationManager.swift</code> – strategie cost-based e feedback runtime.</li>
        </ul>
      </article>
      <article class="layer-map__group">
        <div class="layer-map__title">
          <span>Distribuzione</span>
          <code>Distributed</code>
        </div>
        <ul class="layer-map__list">
          <li><code>Consensus/RaftConsensusManager.swift</code> – log matching, election safety e heartbeat.</li>
          <li><code>DistributedQuery/DistributedQuery.swift</code> – coordinamento federato delle query.</li>
          <li><code>Sharding/ShardingManager.swift</code> – partizionamento logico e routing.</li>
          <li><code>Replication/ReplicationManager.swift</code> – repliche calde e policy di sync.</li>
          <li><code>DistributedTx</code> – protocolli per coordinare transazioni tra shard.</li>
        </ul>
      </article>
      <article class="layer-map__group">
        <div class="layer-map__title">
          <span>Osservabilità &amp; Sicurezza</span>
          <code>Monitoring / Security</code>
        </div>
        <ul class="layer-map__list">
          <li><code>Monitoring/Monitor.swift</code> – metriche, threshold e health routing.</li>
          <li><code>Performance/Benchmarking.swift</code> – profili di carico e analisi runtime.</li>
          <li><code>Authentication/AuthenticationManager.swift</code> – hashing, sessioni e utente admin.</li>
          <li><code>Security/RolesPermissions.swift</code> – ruoli, privilegi e policy row-level.</li>
          <li><code>Policy/PolicyManager.swift</code> – quote, limiti e retention.</li>
        </ul>
      </article>
    </div>
  </div>
</section>

<section class="section section--muted">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Lifecycle della query</span>
      <h2 class="section__title">Sequenza di esecuzione secondo il codice Swift</h2>
      <p class="section__lede">
        Dalla connessione al commit, ogni passaggio è implementato in un attore o manager dedicato. I punti chiave sono
        annotati con invarianti TLA+ direttamente nel file sorgente.
      </p>
    </header>
    <ol class="timeline">
      <li class="timeline__item">
        <h3 class="timeline__title">Connessione e autenticazione</h3>
        <p><code>MultiTenancy/ConnectionPooling.swift</code> consegna connessioni attive, mentre <code>Security/Authentication.swift</code> valida credenziali e sessioni.</p>
      </li>
      <li class="timeline__item">
        <h3 class="timeline__title">Parsing e pianificazione</h3>
        <p><code>SQL/SQLProcessor.swift</code> analizza la query, <code>Planner/QueryPlanner.swift</code> genera il piano logico e <code>Optimization/OptimizationManager.swift</code> sceglie strategie fisiche.</p>
      </li>
      <li class="timeline__item">
        <h3 class="timeline__title">Esecuzione e accesso dati</h3>
        <p><code>Query/QueryExecutor.swift</code> esegue operatori; si interfaccia con <code>BufferPool</code>, <code>HeapTable</code> e <code>IndexManager.swift</code> per scansioni ed accessi indicizzati.</p>
      </li>
      <li class="timeline__item">
        <h3 class="timeline__title">Commit e replica</h3>
        <p><code>TransactionManager</code> registra record nel WAL tramite <code>FileWAL.swift</code>; eventuali transazioni distribuite passano da <code>TwoPhaseCommitManager.swift</code>, con replica assicurata da <code>ReplicationManager.swift</code>.</p>
      </li>
      <li class="timeline__item">
        <h3 class="timeline__title">Monitoraggio e feedback</h3>
        <p><code>Monitoring/Monitor.swift</code> aggiorna metriche e stato, fornendo input a <code>Performance/Benchmarking.swift</code> e alle policy di tuning automatico.</p>
      </li>
    </ol>
  </div>
</section>

<section class="section">
  <div class="shell">
    <header class="section__header">
      <span class="section__eyebrow">Resilienza</span>
      <h2 class="section__title">Recupero, backup e gestione errori interni</h2>
      <p class="section__lede">
        I componenti di protezione lavorano di concerto con WAL e storage. Il codice Swift implementa i passaggi REDO/UNDO
        e i piani di backup integrandosi con il catalogo.
      </p>
    </header>
    <div class="grid grid--three">
      <article class="card">
        <span class="badge">Recovery</span>
        <h3 class="card__title">ARIES step-by-step</h3>
        <p class="card__body">
          <code>Recovery/ARIESRecovery.swift</code> definisce passaggi di analysis, redo e undo; le strutture DPT e transaction table
          sono popolate tramite <code>FileWAL.swift</code> e <code>TransactionManager</code>.
        </p>
      </article>
      <article class="card">
        <span class="badge">Backup</span>
        <h3 class="card__title">Snapshot e retention</h3>
        <p class="card__body">
          <code>Backup/BackupManager.swift</code> orchestra snapshot e restore; sincronizza il catalogo con <code>CatalogManager.swift</code>
          e rispetta le policy definite in <code>Policy/PolicyManager.swift</code>.
        </p>
      </article>
      <article class="card">
        <span class="badge">Fault handling</span>
        <h3 class="card__title">Controllo degli errori</h3>
        <p class="card__body">
          <code>ErrorRecovery</code> e <code>Utilities</code> includono circuit breaker, retry con backoff e strumenti di audit
          usati da <code>ColibrìDB</code> per mantenere consistenza anche in presenza di crash.
        </p>
      </article>
    </div>
  </div>
</section>

<section class="section section--muted">
  <div class="shell">
    <header class="section__header section__header--center">
      <span class="section__eyebrow">Collegamenti rapidi</span>
      <h2 class="section__title">Passa dal diagramma al file concreto</h2>
    </header>
    <div class="highlight-grid">
      <div class="highlight">
        <strong>Schema completo</strong>
        <p>Consulta il codice di <code>Sources/ColibriCore/Database/ColibrìDB.swift</code> per vedere come gli attori vengono istanziati e collegati.</p>
      </div>
      <div class="highlight">
        <strong>Specifica formale</strong>
        <p>I commenti nei file indicano il modulo TLA+ corrispondente: ad esempio <code>spec/WAL.tla</code> per il WAL e <code>spec/ConsensusProtocol.tla</code> per Raft.</p>
      </div>
      <div class="highlight">
        <strong>Server esterno</strong>
        <p><code>Sources/ColibriServer/Server.swift</code> integra il core in un listener HTTP con concurrency via <code>Network</code>.</p>
      </div>
    </div>
  </div>
</section>
