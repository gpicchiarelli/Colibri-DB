<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance - Colibr√¨DB</title>
    <link rel="stylesheet" href="assets/style.css">
</head>
<body>
    <div class="container">
        <h1>üìà Performance</h1>
        
        <h2>Metriche di Performance</h2>

        <h3>Throughput</h3>
        <div class="api-section">
            <h4>Transazioni per Secondo (TPS)</h4>
            <ul>
                <li><strong>Target:</strong> 1000+ TPS</li>
                <li><strong>Read-heavy workload:</strong> 2000+ TPS</li>
                <li><strong>Write-heavy workload:</strong> 500+ TPS</li>
                <li><strong>Mixed workload:</strong> 1000+ TPS</li>
            </ul>

            <h4>Test di Throughput</h4>
            <div class="code-block">
                <pre><code>// Test throughput transazioni
let transactionCount = 1000
let startTime = Date()

for i in 0..<transactionCount {
    let txID = try await db.beginTransaction()
    let row: Row = ["id": .int(i), "name": .string("User\(i)")]
    try await db.insert(table: "users", row: row, txID: txID)
    try await db.commit(txID: txID)
}

let endTime = Date()
let duration = endTime.timeIntervalSince(startTime)
let tps = Double(transactionCount) / duration

logInfo("Throughput: \(tps) TPS", category: .performance)</code></pre>
            </div>
        </div>

        <h3>Latenza</h3>
        <div class="api-section">
            <h4>Latenza Target</h4>
            <ul>
                <li><strong>P50:</strong> < 5ms</li>
                <li><strong>P95:</strong> < 10ms</li>
                <li><strong>P99:</strong> < 50ms</li>
                <li><strong>P99.9:</strong> < 100ms</li>
            </ul>

            <h4>Test di Latenza</h4>
            <div class="code-block">
                <pre><code>// Test latenza operazioni
let operationCount = 1000
var latencies: [TimeInterval] = []

for _ in 0..<operationCount {
    let startTime = Date()
    
    let txID = try await db.beginTransaction()
    let row: Row = ["id": .int(Int.random(in: 1...1000)), "name": .string("Test")]
    try await db.insert(table: "users", row: row, txID: txID)
    try await db.commit(txID: txID)
    
    let endTime = Date()
    latencies.append(endTime.timeIntervalSince(startTime))
}

// Calcola percentili
latencies.sort()
let p50 = latencies[Int(Double(latencies.count) * 0.5)]
let p95 = latencies[Int(Double(latencies.count) * 0.95)]
let p99 = latencies[Int(Double(latencies.count) * 0.99)]

logInfo("Latency - P50: \(p50*1000)ms, P95: \(p95*1000)ms, P99: \(p99*1000)ms", 
        category: .performance)</code></pre>
            </div>
        </div>

        <h3>Recovery Time</h3>
        <div class="api-section">
            <h4>Target di Recovery</h4>
            <ul>
                <li><strong>Crash Recovery:</strong> < 5s per GB di dati</li>
                <li><strong>Checkpoint:</strong> < 1s per GB di dati</li>
                <li><strong>Startup:</strong> < 10s</li>
            </ul>

            <h4>Test di Recovery</h4>
            <div class="code-block">
                <pre><code>// Test recovery time
let startTime = Date()
try await db.start()
let endTime = Date()
let recoveryTime = endTime.timeIntervalSince(startTime)

logInfo("Recovery time: \(recoveryTime)s", category: .performance)</code></pre>
            </div>
        </div>

        <h2>Ottimizzazioni Performance</h2>

        <h3>Configurazione Buffer Pool</h3>
        <div class="api-section">
            <h4>Dimensionamento</h4>
            <ul>
                <li><strong>Regola generale:</strong> 70-80% della RAM disponibile</li>
                <li><strong>Minimo:</strong> 100 pagine (800KB)</li>
                <li><strong>Raccomandato:</strong> 1000+ pagine (8MB+)</li>
            </ul>

            <h4>Configurazione Ottimale</h4>
            <div class="code-block">
                <pre><code>// Per sistema con 8GB RAM
let config = Colibr√¨DBConfiguration(
    bufferPoolSize: 6000,  // ~48MB (6% della RAM)
    walBufferSize: 2 * 1024 * 1024  // 2MB WAL buffer
)</code></pre>
            </div>
        </div>

        <h3>Lock Striping</h3>
        <div class="api-section">
            <h4>Configurazione</h4>
            <div class="code-block">
                <pre><code>{
  "performanceOptimizations": {
    "lockStripingEnabled": true,
    "lockStripeCount": 64  // Aumenta per pi√π concurrency
  }
}</code></pre>
            </div>

            <h4>Benefici</h4>
            <ul>
                <li>Riduce contesa su lock globali</li>
                <li>Migliora throughput concorrente</li>
                <li>Riduce latenza per operazioni parallele</li>
            </ul>
        </div>

        <h3>Query Plan Cache</h3>
        <div class="api-section">
            <h4>Configurazione</h4>
            <div class="code-block">
                <pre><code>{
  "performanceOptimizations": {
    "queryPlanCacheEnabled": true,
    "queryPlanCacheSize": 500  // Numero di piani cached
  }
}</code></pre>
            </div>

            <h4>Benefici</h4>
            <ul>
                <li>Elimina ri-ottimizzazione query frequenti</li>
                <li>Riduce CPU usage</li>
                <li>Migliora latenza query</li>
            </ul>
        </div>

        <h3>Serializzazione Binaria</h3>
        <div class="api-section">
            <h4>Configurazione</h4>
            <div class="code-block">
                <pre><code>{
  "performanceOptimizations": {
    "binarySerializationEnabled": true
  }
}</code></pre>
            </div>

            <h4>Benefici</h4>
            <ul>
                <li>3-5x pi√π veloce di JSON</li>
                <li>Riduce overhead serializzazione</li>
                <li>Migliora throughput I/O</li>
            </ul>
        </div>

        <h2>Monitoring Performance</h2>

        <h3>Metriche Chiave</h3>
        <div class="api-section">
            <h4>Database Statistics</h4>
            <div class="code-block">
                <pre><code>let stats = await db.getStatistics()

// Throughput
logInfo("Transactions/sec: \(stats.transactionsPerSecond)", category: .performance)

// Buffer Pool
logInfo("Buffer pool hit rate: \(stats.bufferPoolHitRate)%", category: .performance)
logInfo("Dirty pages: \(stats.dirtyPages)", category: .performance)

// Concurrency
logInfo("Active transactions: \(stats.activeTransactions)", category: .performance)
logInfo("Lock contention: \(stats.lockContentionCount)", category: .performance)</code></pre>
            </div>
        </div>

        <h3>Logging Performance</h3>
        <div class="api-section">
            <h4>Configurazione Logging</h4>
            <div class="code-block">
                <pre><code>// Logging per performance monitoring
let performanceLogger = Logger(
    handlers: [
        FileLogHandler(fileURL: URL(fileURLWithPath: "/var/log/colibridb_perf.log")),
        ConsoleLogHandler()
    ],
    minLevel: .info
)

// Log metriche periodiche
Task {
    while true {
        let stats = await db.getStatistics()
        await performanceLogger.info("Performance metrics", 
                                   category: .performance,
                                   metadata: [
                                       "tps": stats.transactionsPerSecond,
                                       "latency_p95": stats.latencyP95,
                                       "buffer_hit_rate": stats.bufferPoolHitRate
                                   ])
        try await Task.sleep(nanoseconds: 60_000_000_000) // 60 secondi
    }
}</code></pre>
            </div>
        </div>

        <h2>Benchmark e Testing</h2>

        <h3>Benchmark Suite</h3>
        <div class="api-section">
            <h4>Esegui Benchmark</h4>
            <div class="code-block">
                <pre><code># Esegui benchmark completi
swift run benchmarks

# Benchmark specifici
swift run benchmarks --throughput
swift run benchmarks --latency
swift run benchmarks --recovery</code></pre>
            </div>
        </div>

        <h3>Stress Testing</h3>
        <div class="api-section">
            <h4>Test di Carico</h4>
            <div class="code-block">
                <pre><code>// Test con carico elevato
let concurrentTasks = 100
let operationsPerTask = 1000

await withTaskGroup(of: Void.self) { group in
    for _ in 0..<concurrentTasks {
        group.addTask {
            for _ in 0..<operationsPerTask {
                let txID = try await db.beginTransaction()
                let row: Row = ["id": .int(Int.random(in: 1...10000)), 
                               "name": .string("StressTest")]
                try await db.insert(table: "users", row: row, txID: txID)
                try await db.commit(txID: txID)
            }
        }
    }
}</code></pre>
            </div>
        </div>

        <h2>Best Practices</h2>

        <h3>Configurazione Produzione</h3>
        <div class="api-section">
            <ul>
                <li>Usa <code>logLevel: .warning</code> per ridurre I/O</li>
                <li>Imposta <code>bufferPoolSizeBytes</code> al 70-80% della RAM</li>
                <li>Abilita tutte le ottimizzazioni performance</li>
                <li>Configura <code>periodicCleanupEnabled</code></li>
                <li>Usa SSD per storage</li>
                <li>Monitora metriche continuamente</li>
            </ul>
        </div>

        <h3>Configurazione Sviluppo</h3>
        <div class="api-section">
            <ul>
                <li>Usa <code>logLevel: .debug</code> per debugging</li>
                <li>Abilita <code>metricsEnabled</code> per monitoring</li>
                <li>Usa buffer pool pi√π piccolo per test</li>
                <li>Abilita logging dettagliato</li>
            </ul>
        </div>

        <h2>Prossimi Passi</h2>
        <ul>
            <li><a href="configuration.html">Configuration</a> - Configurazione avanzata</li>
            <li><a href="troubleshooting.html">Troubleshooting</a> - Risoluzione problemi</li>
            <li><a href="api-reference.html">API Reference</a> - Riferimento API completo</li>
        </ul>
    </div>
</body>
</html>