//
//  IndexManager.swift
//  ColibrìDB
//
//  Created by Giacomo Picchiarelli on 2025-09-26.
//
// ColibrìDB — BSD 3-Clause License
// Copyright (c) 2025 Giacomo Picchiarelli
// Licensed under the BSD 3-Clause License. See LICENSE file.

// Theme: Index management system coordinating different index types.

import Foundation
import os.log

/// Index manager coordinating different index types
public final class IndexManager {
    private let logger = Logger(subsystem: "com.colibridb.index", category: "manager")
    private let database: Database
    private var indexes: [String: [String: IndexWrapper]] = [:]
    private let indexLock = NSLock()
    
    public init(database: Database) {
        self.database = database
    }
    
    /// Creates a new index
    public func createIndex(name: String, on table: String, columns: [String], type: IndexType = .bTree) throws {
        logger.info("Creating index \(name) on table \(table) with columns \(columns)")
        
        indexLock.lock()
        defer { indexLock.unlock() }
        
        // Check if index already exists
        if indexes[table]?[name] != nil {
            throw IndexError.indexAlreadyExists(name)
        }
        
        // Create index wrapper
        let wrapper = try createIndexWrapper(name: name, table: table, columns: columns, type: type)
        
        // Store index
        if indexes[table] == nil {
            indexes[table] = [:]
        }
        indexes[table]?[name] = wrapper
        
        logger.info("Index \(name) created successfully")
    }
    
    /// Drops an index
    public func dropIndex(name: String, from table: String) throws {
        logger.info("Dropping index \(name) from table \(table)")
        
        indexLock.lock()
        defer { indexLock.unlock() }
        
        guard let wrapper = indexes[table]?[name] else {
            throw IndexError.indexNotFound(name)
        }
        
        // Close index
        try wrapper.close()
        
        // Remove from indexes
        indexes[table]?.removeValue(forKey: name)
        
        logger.info("Index \(name) dropped successfully")
    }
    
    /// Inserts a key-value pair into an index
    public func insert(key: [UInt8], value: RID, into indexName: String, on table: String) throws {
        guard let wrapper = indexes[table]?[indexName] else {
            throw IndexError.indexNotFound(indexName)
        }
        
        try wrapper.insert(key: key, value: value)
    }
    
    /// Deletes a key-value pair from an index
    public func delete(key: [UInt8], from indexName: String, on table: String) throws {
        guard let wrapper = indexes[table]?[indexName] else {
            throw IndexError.indexNotFound(indexName)
        }
        
        try wrapper.delete(key: key)
    }
    
    /// Searches for a key in an index
    public func search(key: [UInt8], in indexName: String, on table: String) throws -> [RID] {
        guard let wrapper = indexes[table]?[indexName] else {
            throw IndexError.indexNotFound(indexName)
        }
        
        return try wrapper.search(key: key)
    }
    
    /// Searches for a range of keys in an index
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8], in indexName: String, on table: String) throws -> [RID] {
        guard let wrapper = indexes[table]?[indexName] else {
            throw IndexError.indexNotFound(indexName)
        }
        
        return try wrapper.searchRange(from: startKey, to: endKey)
    }
    
    /// Gets index statistics
    public func getStatistics(for indexName: String, on table: String) throws -> IndexStatistics {
        guard let wrapper = indexes[table]?[indexName] else {
            throw IndexError.indexNotFound(indexName)
        }
        
        return try wrapper.getStatistics()
    }
    
    /// Gets all indexes for a table
    public func getIndexes(for table: String) -> [String] {
        indexLock.lock()
        defer { indexLock.unlock() }
        return Array(indexes[table]?.keys ?? [])
    }
    
    /// Gets all tables with indexes
    public func getTables() -> [String] {
        indexLock.lock()
        defer { indexLock.unlock() }
        return Array(indexes.keys)
    }
    
    /// Closes all indexes
    public func closeAll() throws {
        indexLock.lock()
        defer { indexLock.unlock() }
        
        for (table, tableIndexes) in indexes {
            for (name, wrapper) in tableIndexes {
                try wrapper.close()
                logger.info("Closed index \(name) on table \(table)")
            }
        }
        
        indexes.removeAll()
    }
    
    /// Creates an index wrapper based on type
    private func createIndexWrapper(name: String, table: String, columns: [String], type: IndexType) throws -> IndexWrapper {
        switch type {
        case .bTree:
            let path = "\(database.config.dataDir)/indexes/\(table)_\(name).btree"
            let btree = try FileBPlusTreeIndex(path: path, pageSize: database.config.pageSize)
            return BTreeIndexWrapper(btree: btree)
            
        case .art:
            let art = ARTIndex(maxKeyLength: 1024)
            return ARTIndexWrapper(art: art)
            
        case .lsmTree:
            let lsm = LSMTreeIndex(maxMemTableSize: 64 * 1024 * 1024)
            return LSMIndexWrapper(lsm: lsm)
            
        case .hash:
            let hash = HashIndex()
            return HashIndexWrapper(hash: hash)
            
        case .skipList:
            let skipList = SkipListIndex()
            return SkipListIndexWrapper(skipList: skipList)
        }
    }
}

/// Index types
public enum IndexType: String, Codable, CaseIterable {
    case bTree = "BTREE"
    case art = "ART"
    case lsmTree = "LSM"
    case hash = "HASH"
    case skipList = "SKIPLIST"
    
    public var description: String {
        return rawValue
    }
}

/// Index wrapper protocol
public protocol IndexWrapper: AnyObject {
    func insert(key: [UInt8], value: RID) throws
    func delete(key: [UInt8]) throws
    func search(key: [UInt8]) throws -> [RID]
    func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID]
    func getStatistics() throws -> IndexStatistics
    func close() throws
}

/// B+Tree index wrapper
public final class BTreeIndexWrapper: IndexWrapper {
    private let btree: FileBPlusTreeIndex
    
    public init(btree: FileBPlusTreeIndex) {
        self.btree = btree
    }
    
    public func insert(key: [UInt8], value: RID) throws {
        try btree.insert(key: key, rid: value)
    }
    
    public func delete(key: [UInt8]) throws {
        try btree.delete(key: key, rid: RID(pageId: 0, slotId: 0)) // RID not used for deletion
    }
    
    public func search(key: [UInt8]) throws -> [RID] {
        return btree.search(key: key)
    }
    
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID] {
        return btree.searchRange(from: startKey, to: endKey)
    }
    
    public func getStatistics() throws -> IndexStatistics {
        return btree.getStatistics()
    }
    
    public func close() throws {
        btree.close()
    }
}

/// ART index wrapper
public final class ARTIndexWrapper: IndexWrapper {
    private let art: ARTIndex<RID>
    
    public init(art: ARTIndex<RID>) {
        self.art = art
    }
    
    public func insert(key: [UInt8], value: RID) throws {
        art.insert(key: key, rid: value)
    }
    
    public func delete(key: [UInt8]) throws {
        art.delete(key: key)
    }
    
    public func search(key: [UInt8]) throws -> [RID] {
        return art.search(key: key)
    }
    
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID] {
        return art.searchRange(from: startKey, to: endKey)
    }
    
    public func getStatistics() throws -> IndexStatistics {
        return art.getStatistics()
    }
    
    public func close() throws {
        // ART index doesn't need explicit closing
    }
}

/// LSM-Tree index wrapper
public final class LSMIndexWrapper: IndexWrapper {
    private let lsm: LSMTreeIndex<String, RID>
    
    public init(lsm: LSMTreeIndex<String, RID>) {
        self.lsm = lsm
    }
    
    public func insert(key: [UInt8], value: RID) throws {
        lsm.insert(key: key, rid: value)
    }
    
    public func delete(key: [UInt8]) throws {
        lsm.delete(key: key)
    }
    
    public func search(key: [UInt8]) throws -> [RID] {
        return lsm.search(key: key)
    }
    
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID] {
        return lsm.searchRange(from: startKey, to: endKey)
    }
    
    public func getStatistics() throws -> IndexStatistics {
        return lsm.getStatistics()
    }
    
    public func close() throws {
        lsm.close()
    }
}

/// Hash index wrapper
public final class HashIndexWrapper: IndexWrapper {
    private let hash: HashIndex<String, RID>
    
    public init(hash: HashIndex<String, RID>) {
        self.hash = hash
    }
    
    public func insert(key: [UInt8], value: RID) throws {
        hash.insert(key: key, rid: value)
    }
    
    public func delete(key: [UInt8]) throws {
        hash.delete(key: key)
    }
    
    public func search(key: [UInt8]) throws -> [RID] {
        return hash.search(key: key)
    }
    
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID] {
        // Hash index doesn't support range queries
        throw IndexError.operationNotSupported("Range queries not supported on hash index")
    }
    
    public func getStatistics() throws -> IndexStatistics {
        return hash.getStatistics()
    }
    
    public func close() throws {
        // Hash index doesn't need explicit closing
    }
}

/// Skip list index wrapper
public final class SkipListIndexWrapper: IndexWrapper {
    private let skipList: SkipListIndex<String, RID>
    
    public init(skipList: SkipListIndex<String, RID>) {
        self.skipList = skipList
    }
    
    public func insert(key: [UInt8], value: RID) throws {
        skipList.insert(key: key, rid: value)
    }
    
    public func delete(key: [UInt8]) throws {
        skipList.delete(key: key)
    }
    
    public func search(key: [UInt8]) throws -> [RID] {
        return skipList.search(key: key)
    }
    
    public func searchRange(from startKey: [UInt8], to endKey: [UInt8]) throws -> [RID] {
        return skipList.searchRange(from: startKey, to: endKey)
    }
    
    public func getStatistics() throws -> IndexStatistics {
        return skipList.getStatistics()
    }
    
    public func close() throws {
        // Skip list index doesn't need explicit closing
    }
}

/// Index statistics (using the one from Types.swift)
// Removed duplicate definition to resolve ambiguity

/// Index errors
public enum IndexError: Error, LocalizedError {
    case indexNotFound(String)
    case indexAlreadyExists(String)
    case operationNotSupported(String)
    case indexCorrupted(String)
    case insufficientSpace(String)
    case keyTooLong(Int, Int)
    case valueTooLong(Int, Int)
    
    public var errorDescription: String? {
        switch self {
        case .indexNotFound(let name):
            return "Index \(name) not found"
        case .indexAlreadyExists(let name):
            return "Index \(name) already exists"
        case .operationNotSupported(let operation):
            return "Operation not supported: \(operation)"
        case .indexCorrupted(let name):
            return "Index \(name) is corrupted"
        case .insufficientSpace(let message):
            return "Insufficient space: \(message)"
        case .keyTooLong(let actual, let max):
            return "Key too long: \(actual) bytes, maximum \(max) bytes"
        case .valueTooLong(let actual, let max):
            return "Value too long: \(actual) bytes, maximum \(max) bytes"
        }
    }
}

/// Index maintenance manager
public final class IndexMaintenanceManager {
    private let logger = Logger(subsystem: "com.colibridb.index", category: "maintenance")
    private let indexManager: IndexManager
    private var maintenanceTasks: [String: IndexMaintenanceTask] = [:]
    private let taskLock = NSLock()
    
    public init(indexManager: IndexManager) {
        self.indexManager = indexManager
    }
    
    /// Schedules index maintenance
    public func scheduleMaintenance(for indexName: String, on table: String, task: IndexMaintenanceTask) {
        taskLock.lock()
        defer { taskLock.unlock() }
        
        let key = "\(table).\(indexName)"
        maintenanceTasks[key] = task
        logger.info("Scheduled maintenance for index \(indexName) on table \(table)")
    }
    
    /// Runs maintenance for all scheduled indexes
    public func runMaintenance() throws {
        taskLock.lock()
        defer { taskLock.unlock() }
        
        for (key, task) in maintenanceTasks {
            logger.info("Running maintenance for \(key)")
            try task.execute()
        }
    }
    
    /// Removes maintenance task
    public func removeMaintenance(for indexName: String, on table: String) {
        taskLock.lock()
        defer { taskLock.unlock() }
        
        let key = "\(table).\(indexName)"
        maintenanceTasks.removeValue(forKey: key)
        logger.info("Removed maintenance for index \(indexName) on table \(table)")
    }
}

/// Index maintenance task
public protocol IndexMaintenanceTask {
    func execute() throws
}

/// Index compaction task
public struct IndexCompactionTask: IndexMaintenanceTask {
    private let indexManager: IndexManager
    private let indexName: String
    private let table: String
    
    public init(indexManager: IndexManager, indexName: String, table: String) {
        self.indexManager = indexManager
        self.indexName = indexName
        self.table = table
    }
    
    public func execute() throws {
        // This would implement index compaction
        // For now, just log the task
        print("Compacting index \(indexName) on table \(table)")
    }
}

/// Index statistics collection task
public struct IndexStatisticsTask: IndexMaintenanceTask {
    private let indexManager: IndexManager
    private let indexName: String
    private let table: String
    
    public init(indexManager: IndexManager, indexName: String, table: String) {
        self.indexManager = indexManager
        self.indexName = indexName
        self.table = table
    }
    
    public func execute() throws {
        let stats = try indexManager.getStatistics(for: indexName, on: table)
        print("Index \(indexName) statistics: \(stats.entryCount) entries, \(stats.sizeBytes) bytes")
    }
}
